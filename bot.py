import socket
import sqlite3
import sys

#IRC Variables.
ident = "bot"
botnick = "FellowBot" #The nick name of the bot
real = "Python Bot - PM Captain for questions" #This is the "real name" field found in irc clients.
server = "irc.us.gamesurge.net" #The server we want to connect to
port = 6667 #The port of the irc server
ircchannel = "#testingland" #The irc channel.
ircaccount = "FellowshipBot"
ircpass = "captain1299630"
authserv = "AuthServ@Services.GameSurge.net" #The bot that we want to identify to
#Everything below this is now core code.

#Private message function
def privmsg(target, data):
    #Target is the person/channel we want to send to
    #The data is basically the message.
    #To use it just run privmsg("someguy", "hey, what's up?")
    #or privmsg("#channel", "Hello, world!")
    #%s is a placeholder in a string for a variable. i.e. target and data. We are calling these from what we inputted in the function.
    ircsock.send("PRIVMSG %s :%s\n" % (target, data))
    #ircsock is the socket we have created below. doing ircsock.send means we are sending data to the socket (i.e. the irc server)
    #This is part of the "socket" library as we imported above.
    print ("[-->SENDING<--] PRIVMSG %s :%s" % (target, data))

#The first function we use, this is once we have succesffully connect to the IRC server and have started receiving the MOTD
def idandjoin():
    #Only send the password is ircpass is actually there (i.e. defined and is not a blank space or empty string (we call this NULL (or nil in ruby)))
    if ircpass != "" or ircpass is not False:
        #privmsg is the function in action that we created above.
        #Here we are sending authserv (this is the variable, we are calling authserv
        #as referened in the intial declartion)
        privmsg(authserv, "AUTH %s %s" % (ircaccount, ircpass))
        #privmsg(authserv, "AUTH %s %s\n" % (ircaccount, ircpass))
        #as long as there is an IRC channel, join it. This can be turned in to a for loop if the variable assigned above is an array.
    if ircchannel != "" or ircchannel is not False:
        #Again, we are sending the socket data. This is raw IRC commands (JOIN #CHANNEL)
        ircsock.send("JOIN %s\n" % (ircchannel))

dbconn = sqlite3.connect('gt.db', isolation_level=None)
cur = dbconn.cursor()
cur.execute("CREATE TABLE IF NOT EXISTS groups (ID INTEGER PRIMARY KEY AUTOINCREMENT, owner VARCHAR(255) NOT NULL, type VARCHAR(255) NOT NULL, players VARCHAR(255) NOT NULL, district VARCHAR(255) NOT NULL, time INT NOT NULL, maxplayers INT NOT NULL, player1 VARCHAR(255), player2 VARCHAR(255), player3 VARCHAR(255), player4 VARCHAR(255)")


#This physically creates the socket. All your functions should go above this.
ircsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

#Now we are connecting to the server. remember, ircsock is the variable for the socket we have created
#so we are telling our new socket to CONNECT (hence variableofsocket.connect)
ircsock.connect((server, port))

#Here is where we actually start sendind data. We are telling the IRC server our crucial details. This is all IRC protocol stuff.
ircsock.send("USER " + ident + " " + botnick + " " + botnick + " :" + real + " \n")
ircsock.send("NICK " + botnick + "\n")

#ischecked is just a way so we know we made it past the registration part of IRC.
ischecked = 0

#this is our while look. This is always going to run since it's while 1. i.e. while true. It will never stop. Ever. Don't break it.
while 1:
    #Here are are starting to get data. We are now storing what we get in to a variable called ircmsg.
    ircmsg = ircsock.recv(1024)

    #Now we are moving all the new line stuff generated by IRC to tell us what's new.
    ircmsg = ircmsg.strip('\n\r')

    #We are just printing what the line says so we can see.
    print ircmsg

    #st2a is now going to be our array. We are taking the line we have just received and blowing it up in to an array.
    #this means that each word in our string is going to be an element. So you will have to use this data as st2a[0] to get the first word,
    #st2a[1] to get the second word. I called it st2a since it sounds like string to array.
    st2a = ircmsg.split(' ')

    #Python does this cute thing where if we try to ask it "hey, is this element in our array X?" and it doesnt exist, it throws
    #an IndexError. I.E., the index of the array doesn't exist and will proceed to crash. So what we are doing is catching it
    #i.e. saying "Try to do this, and except this kind of error. We will handle it from here."
    #In this case we are just going to pass (i.e. ignore) since we understand what we did wrong and we don't need to proceed
    #further since it's an error we dont care about.
    try:
        #Here what we are doing is taking the first element (word) of our array, (NOTE: All arrays begin at 0. not 1. so the first
        #value of any array will be 0. This is for all languages and sql databases. Know this!) and checking if it is this word.
        #It is encased in str() since we want to convert it in to a string incase it is something else. Since you can't compare
        #variables between types in most cases. So here we are checking "IF the first word in the line we got is "ERROR" and the
        #second line is ":Closing" then we want to the bot to die, since something really bad happened on the far side of the server.
        #We could attempt to reconnect, but you can probably figure out how to do that. This is a tutorial, not a 'give me' :P
        if str(st2a[0]) == "ERROR" and str(st2a[1]) == ":Closing":
            #If the first word is ERROR and the second word is :Closing, then we want to die. We do this by calling sys.exit()
            #sys is part of the library we also imported above, and exit() is calling one of it's functions.
            sys.exit()
    #We are checking to see if it's an IndexError. If it is, then pass. If it's not an IndexError then two things are interesting.
    #Number 1, this is IRC what could this possible return? (except maybe a socket error if the remote host closed the connection)
    #and number 2 it's all text based!
    except IndexError:
        #Continue on with our life, ignore the error.
        pass

    #If our first word in the line is PING, then do this. Remember, when I say line, I mean look above from when we turned the line
    #in to an array by splitting it after each space. That means each character that is not followed by or precceded by a space
    #is going to become an element of our array. We did this using the split() function. i.e. split(" ", inputvalue)
    #The space is our delimitor, so split by spaces. We could have also done things like ":" or "," if we wanna split by colons or commas.
    #but we dont. Since it's IRC.
    if str(st2a[0]) == "PING":
        #We recieved the ping, now lets send it back PONG. What we are doing is we are sending back the second word of the
        #message and stripping out the colon. We don't want the colon in it. So it probably would have looked something like
        #PONG :2342342523. Now that we have .strip()'d it, we are sending back PONG 23423432.
        #When you are sending raw data with .send, make sure you add a \n at the end so it actually goes through! Other wise
        #it wont send and will sit there. Think of \n as "enter".
        ircsock.send('PONG %s\n' % (str(st2a[1]).strip(':')))
        #print what we wrote out to the console because why not
        print('PONG %s' % (str(st2a[1]).strip(':')))

    #This is the weird side of P10 I mentioned. Basically, it wants extra data then what we have given it so we are going give it
    #what it wants. Unless ischecked is 1 (meaning, we have already done this) then continue.
    if ischecked == 0:
        #Try to make sure we dont hit an IndexError
        try:
            #If the second word is 513 and the third word is our bot's nick name
            #then we know it wants the data.
            if str(st2a[1]) == "513" and str(st2a[2]) == str(botnick):
                #We are sending it out nick plus the 9th element of the array with the
                #colon removed. I don't remember what this looks like, but I know it is required in order
                #to connect to a P10 server. (P10 is the protocol the IRCd on GameSurge uses)
                ircsock.send('PONG %s %s\n' % (botnick, st2a[8].strip(':')))
                print('PONG %s %s' % (botnick, st2a[8].strip(':')))
                #Now we are confirmed we have already done this by incrementing ischecked by 1.
                ischecked += 1
        except IndexError:
            print "It was not defined"

    try:
        #If the IRC numeric is 001, then we have successfully made it on the IRC network. 001 is the IRC server's way of
        #announcing the MOTD. This is for IRC clients so they know "Hey, I see 001, so now I can display the MOTD as I want"
        if str(st2a[1]) == "001":
            #We want to now run the function we have created earlier at the top of the file.
            #We want to do this now since we are officially on the network.
            idandjoin()
            print "We are now connecting"
    except IndexError:
        #We are going to exit with a message now, this means when we want it to die we can display a message to help us
        #determine where it crashed/died/closed.
        sys.exit("An error has occured parsing 001")

    try:
        #This is where you'll have fun. Everytime you send a private message,
        #IRC will announce it as PRIVMSG. So the second element of the line will
        #be PRIVMSG.
        if str(st2a[1]) == "PRIVMSG":
            #We now want to get the person's nick. We do this since the person's nick
            #Will be the first element. But this will be their FULL info. i.e. nick!ident@host.
            #So what we are doing is splitting that word by the exclamation point and only using
            #the first part of it. Since by splitting it, we are turning it in to an array
            #we are saying "I only want the first thing out of it."
            nick = ircmsg.split('!')[0][1:]
            #Now we get the channel.
            channel = ircmsg.split(' PRIVMSG ')[-1].split(' :')[0]
            message = ircmsg.split(':')[2]
            m2a = message.split(' ')
            #So what we are doing is taking the giant string the IRCd has sent us and only getting the message. Since (standard) IRC protocol states
            #that there should only be a a semicolon at the beginning of the data and a second before non-protocol generated data is sent,
            #we can say that the 3rd aray (Think about it, split it in 2 places you get 3 parts. Everything before the first : which is nothing, everthing
            #between the first and last semicolon, then the message data.) What we can do now is check if the key word was mentioned as a word in
            #the message. We do this by splitting the message in to an array and checking if the word we want, in this case "hi", was mentioned as a key
            #word. If we wanted to check if someone was mentioning the bot we could if if "hi" in m2a and botnick in m2ta:. Which would respond if someone
            #were to go "hi botnick" or "say hi to botnick". Determing the positioning would be a bit tricker, so for now that is what it does for this
            #basic tutorial.
            if "FellowshipBot pls" in m2a:
                #Have the bot respond now, or do whatever function you want.
                privmsg(channel, "%s pls" % (nick))
                #Say hi to whoever said hit to us!
    except IndexError:
        sys.exit("An error has occured near PRIVMSG")
        #Quit if something goes wrong.

